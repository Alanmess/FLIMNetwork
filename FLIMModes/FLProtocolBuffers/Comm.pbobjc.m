// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: comm.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Comm.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - CommRoot

@implementation CommRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - CommRoot_FileDescriptor

static GPBFileDescriptor *CommRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"pb_comm"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum PB_SUB_COMM

GPBEnumDescriptor *PB_SUB_COMM_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "PbSubCommHeartBeat\000PbSubCommAck\000PbSubCom"
        "mAnk\000PbSubCommUserInfoChange\000PbSubWsHear"
        "tBeat\000PbSubCommNotify\000";
    static const int32_t values[] = {
        PB_SUB_COMM_PbSubCommHeartBeat,
        PB_SUB_COMM_PbSubCommAck,
        PB_SUB_COMM_PbSubCommAnk,
        PB_SUB_COMM_PbSubCommUserInfoChange,
        PB_SUB_COMM_PbSubWsHeartBeat,
        PB_SUB_COMM_PbSubCommNotify,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB_SUB_COMM)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB_SUB_COMM_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB_SUB_COMM_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB_SUB_COMM_PbSubCommHeartBeat:
    case PB_SUB_COMM_PbSubCommAck:
    case PB_SUB_COMM_PbSubCommAnk:
    case PB_SUB_COMM_PbSubCommUserInfoChange:
    case PB_SUB_COMM_PbSubWsHeartBeat:
    case PB_SUB_COMM_PbSubCommNotify:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB_EN_MSG_PROCESS_STEP

GPBEnumDescriptor *PB_EN_MSG_PROCESS_STEP_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "EnMsgProcessStepInit\000EnMsgProcessStepSyn"
        "c\000";
    static const int32_t values[] = {
        PB_EN_MSG_PROCESS_STEP_EnMsgProcessStepInit,
        PB_EN_MSG_PROCESS_STEP_EnMsgProcessStepSync,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB_EN_MSG_PROCESS_STEP)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB_EN_MSG_PROCESS_STEP_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB_EN_MSG_PROCESS_STEP_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB_EN_MSG_PROCESS_STEP_EnMsgProcessStepInit:
    case PB_EN_MSG_PROCESS_STEP_EnMsgProcessStepSync:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PBHeartBeat

@implementation PBHeartBeat

@dynamic iCurStep;

typedef struct PBHeartBeat__storage_ {
  uint32_t _has_storage_[1];
  int32_t iCurStep;
} PBHeartBeat__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "iCurStep",
        .dataTypeSpecific.className = NULL,
        .number = PBHeartBeat_FieldNumber_ICurStep,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PBHeartBeat__storage_, iCurStep),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PBHeartBeat class]
                                     rootClass:[CommRoot class]
                                          file:CommRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PBHeartBeat__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PBCommACK

@implementation PBCommACK

@dynamic wMainCmdId;
@dynamic wSubCmdId;
@dynamic dwExp;

typedef struct PBCommACK__storage_ {
  uint32_t _has_storage_[1];
  int32_t wMainCmdId;
  int32_t wSubCmdId;
  uint32_t dwExp;
} PBCommACK__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "wMainCmdId",
        .dataTypeSpecific.className = NULL,
        .number = PBCommACK_FieldNumber_WMainCmdId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PBCommACK__storage_, wMainCmdId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "wSubCmdId",
        .dataTypeSpecific.className = NULL,
        .number = PBCommACK_FieldNumber_WSubCmdId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PBCommACK__storage_, wSubCmdId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "dwExp",
        .dataTypeSpecific.className = NULL,
        .number = PBCommACK_FieldNumber_DwExp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PBCommACK__storage_, dwExp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PBCommACK class]
                                     rootClass:[CommRoot class]
                                          file:CommRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PBCommACK__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\tA\000\002\010A\000\003\005\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PBCommANK

@implementation PBCommANK

@dynamic wMainCmdId;
@dynamic wSubCmdId;
@dynamic dwExp;
@dynamic dwErrCode;

typedef struct PBCommANK__storage_ {
  uint32_t _has_storage_[1];
  int32_t wMainCmdId;
  int32_t wSubCmdId;
  uint32_t dwExp;
  uint32_t dwErrCode;
} PBCommANK__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "wMainCmdId",
        .dataTypeSpecific.className = NULL,
        .number = PBCommANK_FieldNumber_WMainCmdId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PBCommANK__storage_, wMainCmdId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "wSubCmdId",
        .dataTypeSpecific.className = NULL,
        .number = PBCommANK_FieldNumber_WSubCmdId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PBCommANK__storage_, wSubCmdId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "dwExp",
        .dataTypeSpecific.className = NULL,
        .number = PBCommANK_FieldNumber_DwExp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PBCommANK__storage_, dwExp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "dwErrCode",
        .dataTypeSpecific.className = NULL,
        .number = PBCommANK_FieldNumber_DwErrCode,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PBCommANK__storage_, dwErrCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PBCommANK class]
                                     rootClass:[CommRoot class]
                                          file:CommRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PBCommANK__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\tA\000\002\010A\000\003\005\000\004\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PBWsHeartBeat

@implementation PBWsHeartBeat

@dynamic iCurStep;

typedef struct PBWsHeartBeat__storage_ {
  uint32_t _has_storage_[1];
  int32_t iCurStep;
} PBWsHeartBeat__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "iCurStep",
        .dataTypeSpecific.className = NULL,
        .number = PBWsHeartBeat_FieldNumber_ICurStep,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PBWsHeartBeat__storage_, iCurStep),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PBWsHeartBeat class]
                                     rootClass:[CommRoot class]
                                          file:CommRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PBWsHeartBeat__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
